From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Wed, 24 Jan 2024 08:34:17 +0100
Subject: [PATCH] Optimization: Optimize NearbyPlayers.


diff --git a/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java b/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
index 17ba07cbd4792f63d88ce29d00da280f30c4abff..ab71768d992d5dede28db426729705ad844cae62 100644
--- a/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
+++ b/src/main/java/io/papermc/paper/util/player/NearbyPlayers.java
@@ -120,7 +120,8 @@ public final class NearbyPlayers {
 
     public static final class TrackedChunk {
 
-        public final ReferenceList<ServerPlayer>[] players = new ReferenceList[TOTAL_MAP_TYPES];
+        private final ReferenceList<ServerPlayer>[] players = new ReferenceList[TOTAL_MAP_TYPES]; // Abomination
+        private final ServerPlayer[] immediatePlayer = new ServerPlayer[TOTAL_MAP_TYPES]; // Abomination
         private int nonEmptyLists;
         private int updateCount;
 
@@ -136,16 +137,49 @@ public final class NearbyPlayers {
             return this.players[type.ordinal()];
         }
 
+        // Abomination start
+        public void forEachPlayer(final java.util.function.Consumer<ServerPlayer> action, final NearbyMapType type) {
+            if (immediatePlayer[type.ordinal()] != null) {
+                action.accept(immediatePlayer[type.ordinal()]);
+                return;
+            }
+            if (players[type.ordinal()] == null) return;
+            for (ServerPlayer player : players[type.ordinal()]) {
+                action.accept(player);
+            }
+        }
+
+        public boolean containsPlayers(final NearbyMapType type) {
+            if (players[type.ordinal()] != null || immediatePlayer[type.ordinal()] != null) return true;
+            return false;
+        }
+
+        public boolean containsPlayer(final ServerPlayer player, final NearbyMapType type) {
+            if (immediatePlayer[type.ordinal()] != null) {
+                return immediatePlayer[type.ordinal()] == player;
+            }
+            if (players[type.ordinal()] == null) return false;
+            return players[type.ordinal()].contains(player);
+        }
+        // Abomination end
+
         public void addPlayer(final ServerPlayer player, final NearbyMapType type) {
             ++this.updateCount;
             final int idx = type.ordinal();
-            final ReferenceList<ServerPlayer> list = this.players[idx];
-            if (list == null) {
+            // Abomination start
+            if (immediatePlayer[idx] == null && players[idx] == null) { // Empty
                 ++this.nonEmptyLists;
+                immediatePlayer[idx] = player;
+                return;
+            } else if (immediatePlayer[idx] != null) { // 1 element
+                if (player == immediatePlayer[idx]) throw new IllegalStateException("Already contains player " + player);
                 (this.players[idx] = new ReferenceList<>()).add(player);
+                this.players[idx].add(immediatePlayer[idx]);
+                immediatePlayer[idx] = null;
                 return;
             }
-
+            // Abomination end
+            final ReferenceList<ServerPlayer> list = this.players[idx];
             if (!list.add(player)) {
                 throw new IllegalStateException("Already contains player " + player);
             }
@@ -154,11 +188,17 @@ public final class NearbyPlayers {
         public void removePlayer(final ServerPlayer player, final NearbyMapType type) {
             ++this.updateCount;
             final int idx = type.ordinal();
-            final ReferenceList<ServerPlayer> list = this.players[idx];
-            if (list == null) {
+            // Abomination start
+            if (immediatePlayer[idx] == null && players[idx] == null) { // Empty
                 throw new IllegalStateException("Does not contain player " + player);
+            } else if (immediatePlayer[idx] != null) { // 1 element
+                if (immediatePlayer[idx] != player) throw new IllegalStateException("Does not contain player " + player);
+                immediatePlayer[idx] = null;
+                --this.nonEmptyLists;
+                return;
             }
-
+            // Abomination end
+            final ReferenceList<ServerPlayer> list = this.players[idx];
             if (!list.remove(player)) {
                 throw new IllegalStateException("Does not contain player " + player);
             }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 5f1862fa8e1557708e0b8a19f60a09cf4dbcebed..b88148a41a8797176ef512fe24cc8d2df03adb93 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1335,10 +1335,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 return;
             }
 
-            com.destroystokyo.paper.util.maplist.ReferenceList<ServerPlayer> players =
-                chunk.getPlayers(io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.VIEW_DISTANCE);
-
-            if (players == null) {
+            if (chunk.containsPlayers(io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.VIEW_DISTANCE) == false) { // Abomination
                 this.clearPlayers();
                 return;
             }
@@ -1349,16 +1346,17 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.lastChunkUpdate = currChunkUpdate;
             this.lastTrackedChunk = chunk;
 
-            for (int i = 0, len = players.size(); i < len; ++i) {
-                ServerPlayer player = players.getUnchecked(i);
+            // Abomination start
+            chunk.forEachPlayer((ServerPlayer player) -> {
                 this.updatePlayer(player);
-            }
+            }, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.VIEW_DISTANCE);
+            // Abomination end
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
                 for (ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
                     ServerPlayer player = conn.getPlayer();
-                    if (!players.contains(player)) {
+                    if (!chunk.containsPlayer(player, io.papermc.paper.util.player.NearbyPlayers.NearbyMapType.VIEW_DISTANCE)) { // Abomination
                         this.removePlayer(player);
                     }
                 }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Tue, 30 Jan 2024 13:52:37 +0100
Subject: [PATCH] Multithreading: Multithreader cleanup.


diff --git a/src/main/java/xymb/MultiThreader.java b/src/main/java/xymb/MultiThreader.java
index 618afe7892efe1b0bc2450ac6d2752189182755c..814cd6456d63570ed44259307637b68e5a6cc4b9 100644
--- a/src/main/java/xymb/MultiThreader.java
+++ b/src/main/java/xymb/MultiThreader.java
@@ -8,48 +8,14 @@ import java.util.concurrent.Executors;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.atomic.AtomicInteger;
 import io.papermc.paper.util.TickThread;
+import com.mojang.logging.LogUtils;
+import org.slf4j.Logger;
 
 public class MultiThreader {
+    static final Logger LOGGER = LogUtils.getLogger();
 
     private static final int parallelism = 8;
-    /*
-    private static final Executor executor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreader-%d")
-            .setPriority(Thread.NORM_PRIORITY - 1)
-            .build());
-    private static final Executor lowPriorityExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreaderLow-%d")
-            .setPriority(Thread.NORM_PRIORITY - 2)
-            .build());
-    private static final Executor chunkMapExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreaderHigh-%d")
-            .setPriority(Thread.NORM_PRIORITY)
-            .build());
-    private static AtomicInteger chunkMapTasksRemaining = new AtomicInteger(0);
-
-    private static final Executor broadcastChangesExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreaderHigh-%d")
-            .setPriority(Thread.NORM_PRIORITY)
-            .build());
-    private static AtomicInteger broadcastChangesTasksRemaining = new AtomicInteger(0);
 
-    private static final Executor activateEntitiesExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-activateEntities-%d")
-            .setPriority(Thread.NORM_PRIORITY)
-            .build());
-    private static AtomicInteger activateEntitiesTasksRemaining = new AtomicInteger(0);
-
-    private static final Executor entityExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-entity-%d")
-            .setPriority(Thread.NORM_PRIORITY)
-            .build());
-    private static AtomicInteger entityTasksRemaining = new AtomicInteger(0);
-
-    private static final Executor broadcastExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreaderLow-%d")
-            .setPriority(Thread.NORM_PRIORITY - 2)
-            .build());
-*/
     private static final Executor sendChunkExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
             .setNameFormat("xymb-MultiThreaderHigh-%d")
             .setPriority(Thread.NORM_PRIORITY + 1)
@@ -59,7 +25,12 @@ public class MultiThreader {
     public static void sendChunkExecute(final Runnable runnable) {
         sendChunkRemaining.incrementAndGet();
         sendChunkExecutor.execute(() -> {
-            runnable.run();
+            try {
+                runnable.run();
+            } catch (Throwable t) {
+                io.papermc.paper.util.TraceUtil.printStackTrace(t);
+                LOGGER.error("Exception in multithreaded SendChunk");
+            }
             sendChunkRemaining.decrementAndGet();
         });
     }
@@ -69,30 +40,29 @@ public class MultiThreader {
             waitALittle();
         }
     }
-/*
-    private static final Executor entityTickExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
-            .setNameFormat("xymb-MultiThreaderHigh-%d")
-            .setPriority(Thread.NORM_PRIORITY + 1)
-            .build());*/
-private static final Executor entityTickExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactory() {
-    private final AtomicInteger threadNumber = new AtomicInteger(1);
 
-    @Override
-    public Thread newThread(Runnable r) {
-//        Thread thread = new TickThread(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
-        Thread thread = new TickThreadRunner(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
-        thread.setPriority(Thread.NORM_PRIORITY + 1);
-        ((TickThread)thread).isMultiThreaded = true;
-        return thread;
-    }
-});
+    private static final Executor entityTickExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactory() {
+        private final AtomicInteger threadNumber = new AtomicInteger(1);
 
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new TickThreadRunner(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
+            thread.setPriority(Thread.NORM_PRIORITY + 1);
+            ((TickThread)thread).isMultiThreaded = true;
+            return thread;
+        }
+    });
     private static AtomicInteger entityTickRemaining = new AtomicInteger(0);
 
     public static void entityTickExecute(final Runnable runnable) {
         entityTickRemaining.incrementAndGet();
         entityTickExecutor.execute(() -> {
-            runnable.run();
+            try {
+                runnable.run();
+            } catch (Throwable t) {
+                io.papermc.paper.util.TraceUtil.printStackTrace(t);
+                LOGGER.error("Exception in multithreaded EntityTick");
+            }
             entityTickRemaining.decrementAndGet();
         });
     }
@@ -103,24 +73,28 @@ private static final Executor entityTickExecutor = Executors.newFixedThreadPool(
         }
     }
 
-private static final Executor sendChangesExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactory() {
-    private final AtomicInteger threadNumber = new AtomicInteger(1);
+    private static final Executor sendChangesExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactory() {
+        private final AtomicInteger threadNumber = new AtomicInteger(1);
 
-    @Override
-    public Thread newThread(Runnable r) {
-//        Thread thread = new TickThread(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
-        Thread thread = new TickThreadRunner(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
-        thread.setPriority(Thread.NORM_PRIORITY + 1);
-        ((TickThread)thread).isMultiThreaded = true;
-        return thread;
-    }
-});
+        @Override
+        public Thread newThread(Runnable r) {
+            Thread thread = new TickThreadRunner(r, "xymb-MultiThreaderHigh-" + threadNumber.getAndIncrement());
+            thread.setPriority(Thread.NORM_PRIORITY + 1);
+            ((TickThread)thread).isMultiThreaded = true;
+            return thread;
+        }
+    });
     private static AtomicInteger sendChangesRemaining = new AtomicInteger(0);
 
     public static void sendChangesExecute(final Runnable runnable) {
         sendChangesRemaining.incrementAndGet();
         sendChangesExecutor.execute(() -> {
-            runnable.run();
+            try {
+                runnable.run();
+            } catch (Throwable t) {
+                io.papermc.paper.util.TraceUtil.printStackTrace(t);
+                LOGGER.error("Exception in multithreaded SendChanges");
+            }
             sendChangesRemaining.decrementAndGet();
         });
     }
@@ -131,105 +105,6 @@ private static final Executor sendChangesExecutor = Executors.newFixedThreadPool
         }
     }
 
-/*
-    public static void variousThingsExecute(final Runnable runnable) {
-        if (dev.kaiijumc.kaiiju.KaiijuConfig.asyncVariousPacketThings) lowPriorityExecutor.execute(runnable);
-        else runnable.run();
-    }
-
-    public static void chunkMapExecute(final Runnable runnable) {
-        if (false) {
-            runnable.run();
-            return;
-        }
-        chunkMapTasksRemaining.incrementAndGet();
-        chunkMapExecutor.execute(() -> {
-            runnable.run();
-            chunkMapTasksRemaining.decrementAndGet();
-        });
-    }
-
-    public static void chunkMapFinish() {
-        while (chunkMapTasksRemaining.get() > 0) {
-            java.util.concurrent.locks.LockSupport.parkNanos(10000);
-        }
-
-    }
-
-    public static void broadcastChanges(final Runnable runnable) {
-        if (!dev.kaiijumc.kaiiju.KaiijuConfig.multithreadBroadcastChanges) {
-            runnable.run();
-            return;
-        }
-        broadcastChangesTasksRemaining.incrementAndGet();
-        broadcastChangesExecutor.execute(() -> {
-            runnable.run();
-            broadcastChangesTasksRemaining.decrementAndGet();
-        });
-    }
-
-    public static void broadcastChangesFinish() {
-        while (broadcastChangesTasksRemaining.get() > 0) {
-            java.util.concurrent.locks.LockSupport.parkNanos(10000);
-        }
-    }
-
-    public static void activateEntities(final Runnable runnable) {
-        if (!dev.kaiijumc.kaiiju.KaiijuConfig.multithreadActivateEntities) {
-            runnable.run();
-            return;
-        }
-        activateEntitiesTasksRemaining.incrementAndGet();
-        activateEntitiesExecutor.execute(() -> {
-            runnable.run();
-            activateEntitiesTasksRemaining.decrementAndGet();
-        });
-    }
-
-    public static void activateEntitiesFinish() {
-        while (activateEntitiesTasksRemaining.get() > 0) {
-            java.util.concurrent.locks.LockSupport.parkNanos(10000);
-        }
-    }
-
-    public static void entity(final Runnable runnable) {
-        if (!dev.kaiijumc.kaiiju.KaiijuConfig.multithreadEntities) {
-            runnable.run();
-            return;
-        }
-        entityTasksRemaining.incrementAndGet();
-        entityExecutor.execute(() -> {
-            runnable.run();
-            entityTasksRemaining.decrementAndGet();
-        });
-    }
-
-    public static void entityFinish() {
-        while (entityTasksRemaining.get() > 0) {
-            java.util.concurrent.locks.LockSupport.parkNanos(10000);
-        }
-    }
-
-    public static void broadcastPacket(final Runnable runnable) {
-        if (!dev.kaiijumc.kaiiju.KaiijuConfig.multithreadBroadcastPacket) {
-            runnable.run();
-            return;
-        }
-        broadcastExecutor.execute(() -> {
-            runnable.run();
-        });
-    }
-
-    public static void sendKeepalive(final Runnable runnable) {
-        if (!dev.kaiijumc.kaiiju.KaiijuConfig.multithreadKeepalivePacket) {
-            runnable.run();
-            return;
-        }
-        broadcastExecutor.execute(() -> {
-            runnable.run();
-        });
-    }*/
-
     private static final Executor serverboundExecutor = Executors.newFixedThreadPool(parallelism, new ThreadFactoryBuilder()
             .setNameFormat("xymb-MultiThreaderHigh-%d")
             .setPriority(Thread.NORM_PRIORITY + 1)
@@ -239,7 +114,12 @@ private static final Executor sendChangesExecutor = Executors.newFixedThreadPool
     public static void serverboundExecute(final Runnable runnable) {
         serverboundRemaining.incrementAndGet();
         serverboundExecutor.execute(() -> {
-            runnable.run();
+            try {
+                runnable.run();
+            } catch (Throwable t) {
+                io.papermc.paper.util.TraceUtil.printStackTrace(t);
+                LOGGER.error("Exception in multithreaded Serverbound");
+            }
             serverboundRemaining.decrementAndGet();
         });
     }
